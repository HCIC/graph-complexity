<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://cdn.jsdelivr.net/lodash/4.17.4/lodash.js"></script>

<svg id="graphsvg">
<g id="edgelines"></g>
<g id="vertexcircles"></g>
</svg>

<div id="parameter_inputs"></div>

<script>
  var p = {
    "width": 600,
    "height": 600,
    "vertexRadius": 10,
    "vertexColor": "black",
    "edgeColor": "black",
    "backgroundColor": "white",

    "repelStrength": -100,
    "gravityStrength": 0.03,
  }

  var vertexColorLab = d3.lab(p.vertexColor);
  var edgeColorLab = d3.lab(p.edgeColor);
  var backgroundColorLab = d3.lab(p.backgroundColor);
  _.merge(p, {
    "vertexColorLab_l": vertexColorLab.l,
    "vertexColorLab_a": vertexColorLab.a,
    "vertexColorLab_b": vertexColorLab.b,
    "edgeColorLab_l": edgeColorLab.l,
    "edgeColorLab_a": edgeColorLab.a,
    "edgeColorLab_b": edgeColorLab.b,
    "backgroundColorLab_l": backgroundColorLab.l,
    "backgroundColorLab_a": backgroundColorLab.a,
    "backgroundColorLab_b": backgroundColorLab.b,
  });


  //TODO: browser
  //TODO: screen resolution

  function gilbert(n, p) {
    var v = [];
    for (var i = 0; i < n; i++) {
      v.push({
        "id": String(i)
      });
    }
    var e = [];
    for (var i = 0; i < v.length; i++) {
      for (var j = i + 1; j < v.length; j++) {
        if (Math.random() <= p) {
          e.push({
            "source": String(i),
            "target": String(j)
          });
        }
      }
    }
    return {
      "vertices": v,
      "edges": e
    };
  }

  var graph = gilbert(20, 0.1)

  /*  var vertices = [{
      "id": "Alice"
    }, {
      "id": "Bob"
    }, {
      "id": "Carol"
    }];

    var edges = [{
      "source": "Alice",
      "target": "Bob"
    }, {
      "source": "Bob",
      "target": "Carol"
    }];
    */

  d3.select("#graphsvg")
    .attr("width", p.width)
    .attr("height", p.height)
    .style("background-color", p.backgroundColor)
    .style("border", "1px solid black")

  var simulation = d3.forceSimulation()
    .force("center", d3.forceCenter(p.width / 2, p.height / 2))
    .force("gravityx", d3.forceX(p.width / 2).strength(p.gravityStrength))
    .force("gravityy", d3.forceY(p.height / 2).strength(p.gravityStrength))
    .force("charge", d3.forceManyBody().strength(p.repelStrength))
    .force("link", d3.forceLink().id(function(d) {
      return d.id;
    }))
    .force("collide", d3.forceCollide(p.vertexRadius));

  simulation.nodes(graph.vertices);
  simulation.force("link").links(graph.edges);
  simulation.stop();
  while (simulation.alpha() >= simulation.alphaMin()) {
    simulation.tick();
  }

  d3.select("#vertexcircles").selectAll("circle").data(graph.vertices).enter()
    .append("circle")
    .attr("r", p.vertexRadius)
    .attr("cx", function(d) {
      return d.x;
    })
    .attr("cy", function(d) {
      return d.y;
    })
    .attr("fill", p.vertexColor)

  d3.select("#edgelines").selectAll("line").data(graph.edges).enter()
    .append("line")
    .attr("x1", function(d) {
      return d.source.x;
    })
    .attr("y1", function(d) {
      return d.source.y;
    })
    .attr("x2", function(d) {
      return d.target.x;
    })
    .attr("y2", function(d) {
      return d.target.y;
    })
    .attr("stroke", p.edgeColor);

  var pdata = [];
  for (var key in p) {
    pdata.push({
      "name": key,
      "value": p[key]
    });
  }
  d3.select("#parameter_inputs").selectAll("input").data(pdata).enter()
    .append("input")
    .attr("type", "hidden")
    .attr("name", function(d) {
      return d.name;
    })
    .attr("value", function(d) {
      return d.value;
    });
</script>
